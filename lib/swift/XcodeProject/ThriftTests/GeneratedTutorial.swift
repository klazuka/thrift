import Foundation
import Thrift


// Typically this is code that would be generated by the Thrift compiler,
// but I am writing it by hand while building-out the runtime.

// TODO how to handle the included "shared.thrift" IDL?

typealias MyInteger = Int32

let INT32CONSTANT: Int32 = 9853
let MAPCONSTANT: [String : String] = ["hello":"world", "goodnight":"moon"]

enum Operation: Int32 {
    case ADD = 1
    case SUBTRACT = 2
    case MULTIPLY = 3
    case DIVIDE = 4
}

struct Work: TBase {
    var num1: Int32 = 0
    var num2: Int32 = 0
    var op: Operation = .ADD
    var comment: String?
    
    init(num1: Int32, num2: Int32, op: Operation, comment: String?) {
        self.num1 = num1
        self.num2 = num2
        self.op = op
        self.comment = comment
    }
    
    init(thriftProtocol: TProtocol) {
        let p = thriftProtocol
        p.readStructBegin()
        
        var exit = false
        while !exit {
            switch p.readFieldBegin() {
            case .Stop:
                exit = true // TODO use labeled break?
            case .Data(_, .I32, 1):
                self.num1 = p.readI32()
            case .Data(_, .I32, 2):
                self.num2 = p.readI32()
            case .Data(_, .I32, 3):
                self.op = unwrapOrDie(Operation.fromRaw(p.readI32()), msg:"bad input: invalid operation value")
            case .Data(_, .String, 4):
                self.comment = p.readString()
            case let .Data(_, elementType, _):
                skip(p, elementType)
            }
            p.readFieldEnd()
        }
        
        p.readStructEnd()
    }
    
    func write(thriftProtocol: TProtocol) {
        let p = thriftProtocol
        p.writeStructBegin("Work")
        writeField(p, .I32, 1) { p.writeI32(self.num1) }
        writeField(p, .I32, 2) { p.writeI32(self.num2) }
        writeField(p, .I32, 3) { p.writeI32(self.op.toRaw()) }
        if comment != nil {
            writeField(p, .String, 4) { p.writeString(self.comment!) }
        }
        p.writeFieldStop()
        p.writeStructEnd()
    }
}

class InvalidOperation: NSException, TBase {
    let what: Int32 = 0  // TODO: remove default: workaround for a Swift bug
    let why: String = "" // TODO: remove default: workaround for a Swift bug
    
    required init(coder aDecoder: NSCoder!) {
        fatalError("not supported")
    }
    
    required init(thriftProtocol: TProtocol) {
        let p = thriftProtocol
        p.readStructBegin()
        
        var exit = false
        while !exit {
            switch p.readFieldBegin() {
            case .Stop:
                exit = true // TODO use labeled break?
            case .Data(_, .I32, 1):
                self.what = p.readI32()
            case .Data(_, .String, 2):
                self.why = p.readString()
            case let .Data(_, elementType, _):
                skip(p, elementType)
            }
            p.readFieldEnd()
        }
        
        p.readStructEnd()
        super.init(name: "InvalidOperation", reason: "what=\(what) why=\(why)", userInfo: nil)
    }
    
    func write(thriftProtocol: TProtocol) {
        let p = thriftProtocol
        p.writeStructBegin("InvalidOperation")
        writeField(p, .I32, 1) { p.writeI32(self.what) }
        writeField(p, .String, 2) { p.writeString(self.why) }
        p.writeFieldStop()
        p.writeStructEnd()
    }
}

// should the RPC commands throw exceptions or return enum values capturing the error

protocol Calculator {
    func ping() // throws TException
    func add(#num1: Int32, num2: Int32) -> Int32 // throws TException
    func calculate(#logid: Int32, w: Work) -> Int32 // throws InvalidOperation, TException
    func zip() // oneway, throws TException
}

private struct _AddArgs: TBase {
    let num1: Int32 = 0 // TODO: remove this default value once Swift init compiler bug fixed
    let num2: Int32 = 0 // TODO: remove this default value once Swift init compiler bug fixed
    
    init(num1: Int32, num2: Int32) {
        self.num1 = num1
        self.num2 = num2
    }
    
    init(thriftProtocol: TProtocol) {
        let p = thriftProtocol
        p.readStructBegin()
        
        var exit = false
        while !exit {
            switch p.readFieldBegin() {
            case .Stop:
                exit = true // TODO use labeled break?
            case let .Data(_, .I32, 1):
                self.num1 = thriftProtocol.readI32()
            case let .Data(_, .I32, 2):
                self.num2 = thriftProtocol.readI32()
            case let .Data(_, elementType, _):
                skip(p, elementType)
            }
            p.readFieldEnd()
        }
        
        p.readStructEnd()
    }
    
    func write(thriftProtocol: TProtocol) {
        let p = thriftProtocol
        p.writeStructBegin("add_args")
        p.writeFieldBegin("num1", type: .I32, id: 1)
        p.writeI32(self.num1)
        p.writeFieldEnd()
        p.writeFieldBegin("num2", type: .I32, id: 2)
        p.writeI32(self.num2)
        p.writeFieldEnd()
        p.writeFieldStop()
        p.writeStructEnd()
    }
}

private struct _AddResult: TBase {
    let success: Int32 = 0 //TODO: remove default value once swift compiler bug is fixed
    
    init(success: Int32) {
        self.success = success
    }
    
    init(thriftProtocol: TProtocol) {
        let p = thriftProtocol
        p.readStructBegin()
        
        var exit = false
        while !exit {
            switch p.readFieldBegin() {
            case .Stop:
                exit = true // TODO use labeled break?
            case let .Data(_, .I32, RPC_RESULT_FIELD_ID):
                self.success = thriftProtocol.readI32()
            case let .Data(_, elementType, _):
                skip(p, elementType)
            }
            p.readFieldEnd()
        }
        
        p.readStructEnd()
    }
    
    func write(thriftProtocol: TProtocol) {
        let p = thriftProtocol
        p.writeStructBegin("add_result")
        p.writeFieldBegin("success", type: .I32, id: RPC_RESULT_FIELD_ID)
        p.writeI32(self.success)
        p.writeFieldEnd()
        p.writeFieldStop()
        p.writeStructEnd()
    }
}

private struct _CalculateArgs: TBase {
    let logid: Int32 = 0 // TODO: remove this default value once Swift init compiler bug fixed
    let w: Work
    
    init(logid: Int32, w: Work) {
        self.logid = logid
        self.w = w
    }
    
    init(thriftProtocol: TProtocol) {
        let p = thriftProtocol
        p.readStructBegin()
        
        // TODO remove this default value once Swift init compiler bug fixed
        let n1: Int32 = 4
        let n2: Int32 = 3
        self.w = Work(num1: n1, num2: n2, op: .ADD, comment: nil)
        
        var exit = false
        while !exit {
            switch p.readFieldBegin() {
            case .Stop:
                exit = true // TODO use labeled break?
            case let .Data(_, .I32, 1):
                self.logid = thriftProtocol.readI32()
            case let .Data(_, .Struct, 2):
                self.w = Work(thriftProtocol: thriftProtocol)
            case let .Data(_, elementType, _):
                skip(p, elementType)
            }
            p.readFieldEnd()
        }
        
        p.readStructEnd()
    }
    
    func write(thriftProtocol: TProtocol) {
        let p = thriftProtocol
        p.writeStructBegin("calculate_args")
        p.writeFieldBegin("logid", type: .I32, id: 1)
        p.writeI32(self.logid)
        p.writeFieldEnd()
        p.writeFieldBegin("w", type: .Struct, id: 2)
        self.w.write(thriftProtocol)
        p.writeFieldEnd()
        p.writeFieldStop()
        p.writeStructEnd()
    }
}

private struct _CalculateResult: TBase {
    let success: Int32?
    let ouch: InvalidOperation?
    
    init(success: Int32?, ouch: InvalidOperation?) {
        self.success = success
        self.ouch = ouch
    }
    
    init(thriftProtocol: TProtocol) {
        let p = thriftProtocol
        p.readStructBegin()
        
        var exit = false
        while !exit {
            switch p.readFieldBegin() {
            case .Stop:
                exit = true // TODO use labeled break?
            case let .Data(_, .I32, RPC_RESULT_FIELD_ID):
                self.success = thriftProtocol.readI32()
            case let .Data(_, .Struct, 1):
                self.ouch = InvalidOperation(thriftProtocol: thriftProtocol)
            case let .Data(_, elementType, _):
                skip(p, elementType)
            }
            p.readFieldEnd()
        }
        
        p.readStructEnd()
    }
    
    func write(thriftProtocol: TProtocol) {
        let p = thriftProtocol
        p.writeStructBegin("calculate_result")
        
        switch (self.success, self.ouch) {
        case let (.Some(success), _):
            p.writeFieldBegin("success", type: .I32, id: RPC_RESULT_FIELD_ID)
            p.writeI32(success)
            p.writeFieldEnd()
        case let (_, .Some(ouch)):
            p.writeFieldBegin("ouch", type: .Struct, id: 1)
            ouch.write(p)
            p.writeFieldEnd()
        default:
            fatalError("protocol violation: either RPC result or exception must be set")
        }
        p.writeFieldStop()
        p.writeStructEnd()
    }
}


class CalculatorClient: Calculator {
    let inProtocol: TProtocol
    let outProtocol: TProtocol
    init(inProtocol: TProtocol, outProtocol: TProtocol) {
        self.inProtocol = inProtocol
        self.outProtocol = outProtocol
    }
    
    func ping() {
        func send_ping() {
            outProtocol.writeMessageBegin(MessageHeader(name: "ping", type: .Call, sequenceID: 0))
            _EmptyThriftStruct(name: "ping_args").write(outProtocol)
            outProtocol.writeMessageEnd()
            outProtocol.transport.flush()
        }
        func recv_ping() {
            let header = inProtocol.readMessageBegin()
            switch (header.name, header.type) {
            case ("ping", .Reply):
                _EmptyThriftStruct(thriftProtocol: inProtocol)
            case ("ping", .Exception):
                inProtocol.readStructBegin()
                inProtocol.readFieldBegin()
                inProtocol.readStructEnd()
            default:
                fatalError("received invalid message")
            }
            inProtocol.readMessageEnd()
        }
        send_ping()
        recv_ping()
    }
    
    func add(#num1: Int32, num2: Int32) -> Int32 {
        func send_add() {
            outProtocol.writeMessageBegin(MessageHeader(name: "add", type: .Call, sequenceID: 0))
            _AddArgs(num1: num1, num2: num2).write(outProtocol)
            outProtocol.writeMessageEnd()
            outProtocol.transport.flush()
        }
        func recv_add() -> Int32 {
            let header = inProtocol.readMessageBegin()
            switch (header.name, header.type) {
            case ("add", .Exception):
                let exc = TApplicationException(thriftProtocol: inProtocol)
                fatalError("implement me: raise exception")
            case ("add", .Reply):
                let result = _AddResult(thriftProtocol: inProtocol)
                inProtocol.readMessageEnd()
                return result.success
            default:
                fatalError("received invalid message")
            }
            inProtocol.readMessageEnd()
        }
        send_add()
        return recv_add()
    }
    
    func calculate(#logid: Int32, w: Work) -> Int32 {
        func send_calculate() {
            outProtocol.writeMessageBegin(MessageHeader(name: "calculate", type: .Call, sequenceID: 0))
            _CalculateArgs(logid: logid, w: w).write(outProtocol)
            outProtocol.writeMessageEnd()
            outProtocol.transport.flush()
        }
        func recv_calculate() -> Int32 {
            let header = inProtocol.readMessageBegin()
            switch (header.name, header.type) {
            case ("calculate", .Exception):
                let exc = TApplicationException(thriftProtocol: inProtocol)
                fatalError("implement me: raise exception")
            case ("calculate", .Reply):
                let result = _CalculateResult(thriftProtocol: inProtocol)
                inProtocol.readMessageEnd()
                switch (result.success, result.ouch) {
                case let (.Some(success), _): return success
                case let (_, .Some(ouch)):
                    // TODO raise exception
                    fatalError("implement me: raise exception")
                default:
                    fatalError("this should never happen")
                }
                inProtocol.readMessageEnd()
            default:
                fatalError("received invalid message")
            }
        }
        send_calculate()
        return recv_calculate()
    }
    
    func zip() {
        func send_zip() {
            outProtocol.writeMessageBegin(MessageHeader(name: "zip", type: .Call, sequenceID: 0))
            _EmptyThriftStruct(name: "zip_args")
            outProtocol.writeMessageEnd()
            outProtocol.transport.flush()
        }
        send_zip()
    }
}
